<html><head><title>acoustic_report</title><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_a6o5ekz6umr6-1>li:before{content:"\0025cb  "}ul.lst-kix_hxhbaganimh7-0{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-8{list-style-type:none}.lst-kix_a6o5ekz6umr6-4>li:before{content:"\0025cb  "}.lst-kix_a6o5ekz6umr6-5>li:before{content:"\0025a0  "}.lst-kix_a6o5ekz6umr6-0>li:before{content:"\0025cf  "}.lst-kix_hxhbaganimh7-2>li:before{content:"\0025a0  "}.lst-kix_hxhbaganimh7-3>li:before{content:"\0025cf  "}ul.lst-kix_hxhbaganimh7-5{list-style-type:none}ul.lst-kix_hxhbaganimh7-6{list-style-type:none}ul.lst-kix_hxhbaganimh7-7{list-style-type:none}ul.lst-kix_hxhbaganimh7-8{list-style-type:none}.lst-kix_hxhbaganimh7-8>li:before{content:"\0025a0  "}.lst-kix_hxhbaganimh7-1>li:before{content:"\0025cb  "}ul.lst-kix_hxhbaganimh7-1{list-style-type:none}.lst-kix_a6o5ekz6umr6-8>li:before{content:"\0025a0  "}ul.lst-kix_hxhbaganimh7-2{list-style-type:none}.lst-kix_hxhbaganimh7-4>li:before{content:"\0025cb  "}ul.lst-kix_hxhbaganimh7-3{list-style-type:none}ul.lst-kix_hxhbaganimh7-4{list-style-type:none}.lst-kix_a6o5ekz6umr6-2>li:before{content:"\0025a0  "}.lst-kix_hxhbaganimh7-0>li:before{content:"\0025cf  "}.lst-kix_hxhbaganimh7-5>li:before{content:"\0025a0  "}.lst-kix_a6o5ekz6umr6-6>li:before{content:"\0025cf  "}.lst-kix_a6o5ekz6umr6-3>li:before{content:"\0025cf  "}.lst-kix_a6o5ekz6umr6-7>li:before{content:"\0025cb  "}.lst-kix_hxhbaganimh7-6>li:before{content:"\0025cf  "}.lst-kix_hxhbaganimh7-7>li:before{content:"\0025cb  "}ul.lst-kix_a6o5ekz6umr6-4{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-5{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-6{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-7{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-0{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-1{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-2{list-style-type:none}ul.lst-kix_a6o5ekz6umr6-3{list-style-type:none}ol{margin:0;padding:0}.c1{widows:2;orphans:2;height:11pt;text-align:center;direction:ltr}.c2{widows:2;orphans:2;height:11pt;direction:ltr}.c7{widows:2;orphans:2;text-align:justify;direction:ltr}.c3{widows:2;orphans:2;text-align:center;direction:ltr}.c9{widows:2;orphans:2;direction:ltr}.c12{text-indent:36pt;text-align:justify}.c19{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c10{color:#1155cc;text-decoration:underline}.c16{margin-right:72pt;margin-left:72pt}.c15{color:inherit;text-decoration:inherit}.c18{margin:0;padding:0}.c4{font-weight:bold}.c20{font-size:14pt}.c14{page-break-after:avoid}.c6{margin-left:36pt}.c8{padding-left:0pt}.c17{background-color:#ffff00}.c13{text-align:justify}.c0{font-family:"Times New Roman"}.c21{text-align:right}.c5{background-color:#ffffff}.c11{font-style:italic}.title{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:21pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}.subtitle{widows:2;padding-top:0pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:13pt;font-family:"Trebuchet MS";padding-bottom:10pt;page-break-after:avoid}li{color:#000000;font-size:11pt;font-family:"Times New Roman"}p{color:#000000;font-size:11pt;margin:0;font-family:"Times New Roman"}h1{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:11pt;font-family:"Times New Roman";padding-bottom:0pt;page-break-after:avoid}h2{widows:2;padding-top:10pt;line-height:1.15;orphans:2;text-align:left;color:#000000;font-size:13pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h3{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:12pt;font-family:"Trebuchet MS";font-weight:bold;padding-bottom:0pt;page-break-after:avoid}h4{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;text-decoration:underline;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h5{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}h6{widows:2;padding-top:8pt;line-height:1.15;orphans:2;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Trebuchet MS";padding-bottom:0pt;page-break-after:avoid}</style></head><body class="c5 c19"><p class="c3"><span class="c0 c20">Acoustical Mesh Network Report</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span>Nathan McCloskey</span></p><p class="c3"><span class="c0">Cameron Spiller</span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">Advisor: Dr. Marojevic Vuk</span></p><p class="c3"><span class="c0">Completed: Fall 2014</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c16"><span class="c0">This Independent Study final report is submitted in partial fulfillment of the requirements for the degree of:</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">B.S. in Computer Engineering</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c3"><span class="c0">Department of Electrical and Computer Engineering</span></p><p class="c3"><span class="c0">College of Engineering</span></p><p class="c3"><span class="c0">Virginia Tech</span></p><p class="c3"><span class="c0">Blacksburg, Virginia</span></p><p class="c3"><span class="c0">USA</span></p><hr style="page-break-before:always;display:none;"><p class="c9"><span class="c4 c0">ABSTRACT</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">The primary goal of this study is the design and implementation of an acoustical mesh network. The physical medium of transmission is ultrasonic and near ultrasonic frequencies. The targeted applications include covert operations in transient settings and aquatic communication systems. The study documents the development of a software defined networking stack including hardware, protocol, and application. The study then describes and demonstrates physical and usage test cases. Finally the study concludes with a description of further research topics and applications. </span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0 c4">KEYWORDS</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">mesh network, acoustic networking, covert networks, aquatic networking</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c4 c0">ACKNOWLEDGEMENTS</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">The authors are both grateful for the help, guidance, and patience of Prof. Vuk. </span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c4 c0">CONTENTS</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 1 Introduction</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 2 </span><span>Software Interface</span><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 3 Protocol</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 4 Implementation</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 5 Testing</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Chapter 6 Conclusion</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">References</span></p><p class="c2"><span class="c0"></span></p><p class="c9"><span class="c0">Appendix </span></p><p class="c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c2"><span class="c0"></span></p><h1 class="c7 c14"><a name="h.4a14322lqrqv"></a><span class="c4">CHAPTER 1: INTRODUCTION</span></h1><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>The goal of the study is to implement a rudimentary mesh network using commodity laptop hardware. Similar studies have been done with a focus on covert applications and have been more specialized to work in underwater settings. This study was performed in an attempt to learn about Software Defined Radios (SDRs) and mesh networking. The primary goal was to implement a rudimentary mesh network based on an original networking protocol and physical layer (Figure 1). </span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 122.00px; height: 244.00px;"><img alt="Untitled Diagram.png" src="images/image08.png" style="width: 122.00px; height: 244.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 1: Layers of acoustical mesh network</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>The physical medium utilized was ultrasonic or near ultrasonic frequencies. Standard commodity laptops with built in speaker and microphone hardware were utilized. These included two 2014 MacBook Airs, a 2011 ThinkPad X220T, and a 2011 Fujitsu T901. GNURadio was chosen for audio processing and protocol implementation. </span></p><h1 class="c7 c14"><a name="h.3gtvalobhn35"></a><span class="c4">CHAPTER 2: SOFTWARE INTERFACE</span></h1><p class="c2 c13"><span></span></p><p class="c7"><span>Several software suites were reviewed beforehand in order to determine the most optimal setup. After consulting people in the field and researching, mini-modem and GNURadio were the two best options for the investigation. After further review though, mini-modem was deemed not robust enough because it did not provide a lot of the same signal processing features as GNURadio.</span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>GNURadio is a software development kit that facilitates block based construction of software defined radios. Because of its general ease of use and open nature it was chosen as the tool for construction of the software interface. GNURadio allows for the creation of flowgraphs made up of many blocks with connections between their inputs and outputs. These flowgraphs can then generate Python source that creates and controls the connections between constituent blocks. These constituent blocks can be either implemented in Python or C/CPP. The top block can then be used in other flowgraphs to represent an encapsulated process. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span>The original design resulted in three very distinct layers across different technologies, linked via standard interprocess communication (IPC). The physical and data link layers were implemented in GNURadio while the networking layer was implemented in a separate python process. These layers were connected originally vias TCP sockets, but this transitioned to anonymous pipes across processes. The phsical/data layer was split into two processes: a Tx and Rx process. Both flowgraphs operated separately and essentially performed identical operations, but in different directions. These flowgraphs and generated python modules were aptly named AcoustIn and AcoustOut. </span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>The flowgraphs were constructed from a series of blocks that processed raw audio source into packets routed to an IPC sink or from packets fed from an IPC source to an audio sink (Figure 2) (Figure 3). The packet encoder operated on a strict payload size and would block until the IPC source filled the buffer. Once framed with error correction data the packet encoder streamified the packetized data units (PDUs). This stream was fed to a modulator unit. Gaussian frequency shift keying (GFSK) because of its resistance to environmental acoustic noise. The increase in reliable transmission observed after switching from gaussian minimum shift keying (GMSK) was overwhelming. After modulation the stream is resampled to 48 kHz and fed into a frequency translating filter. It shifts the center frequency of the signal to the desired signal level. It applies a pass filter and finally decimates the signal (divides the signal). After these tasks the signal is shifted down or up by a certain frequency in order to bring it out of audible range during operation. Finally the stream is translated from complex numbers to real numbers and pushed to an audio sink with the final sample rate of 48 kHz. </span></p><p class="c2 c13"><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 216.00px;"><img alt="Screen Shot 2014-12-15 at 11.16.07 PM.png" src="images/image00.png" style="width: 624.00px; height: 216.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 2: AcoustIn flowgraph with file descriptor sink.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 280.00px;"><img alt="Screen Shot 2014-12-15 at 11.18.04 PM.png" src="images/image06.png" style="width: 624.00px; height: 280.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 3: AcoustOut flowgraph with file descriptor sink.</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>Testing showed incredibly promising results with these implementations. On a single computer listening to its own echo transmission was particularly reliable. However a very glaring defect was noted. A buffering issue occurred on the receiving end which resulted in a packet delivery delay. Outgoing messages were immediately sent once the payload buffer was filled. They were not received however until a second packet pushed the first packet through. This delay proved to be difficult when designing the packet protocol. The original protocol worked around the delay issue but efforts. To attempt to resolve the issue several forms of IPC and specific bufferless IPC configurations were used. The file descriptors were flushed and set to non buffered mode. This did not show any signs of improvement. A switch was made to unix named pipes (FIFOs). These provided a number of benefits by providing an external point of entry for the network logic allowing the processes to be completely discrete and allowing the raw interface to be accessible separately. This model was satisfactory however it still did not solve the buffering on receipt issue. Finally an effort was made to use UDP sources and sinks for networking. This did not fix the buffering issue, however it was deemed the superior form of IPC and provided the most convenient reliable connection between the data/physical and networking layers.</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>To finally solve the continuing issues with buffering on the receiving end the assistance of the GNURadio community was employed. After interacting with the community it was discovered that the chosen packet decoder and encoder blocks were rudimentary in design and insufficient for our use case. A mailing list thread pointed to an alternative that was only introduced in April 2014 and had yet to make it to the official GNURadio distribution. The set blocks, collectively known as gr-mac, provided a means to communicate with PDUs over universal software radio peripherals (USRPs). The project provided a modem block that framed and deframed packets before sending them across the wire. It additionally described a method of defining a protocol within a GNURadio block that would end up highly influencing the protocol implementation. </span></p><p class="c2 c12"><span></span></p><p class="c7"><span>The provided modem contained a GMSK block along with a series of blocks that convert PDUs to serial data streams (Figure 4). These transformations are vital to get the data from application out to the wire. The proved to be more robust than the default packet encoder/decoder pair that come with GnuRadio and were free of the buffering issues on the receive end. The included examples also introduced alternate organizational models and designs. Rather than have separate top blocks to represent the Tx and Rx functionality along with two separate IPC endpoints, a read only and write only, Tx and Rx are unified and a single server, represented by a block called socket PDU, serves as the IPC interface. </span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 290.67px;"><img alt="Screen Shot 2014-12-16 at 2.00.26 AM.png" src="images/image07.png" style="width: 624.00px; height: 290.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 4: the GMSK radio apart of the gr-mac project</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>After verifying the reliability of the GMSK radio (and again noting the poor performance of GMSK in acoustic applications) the modem was modified to replace the modulator/demodulator with a GFSK version (Figure 5). This block was then compiled to a GNURadio heir block to then be used in other flowgraphs, reducing the visual complexity of the flowgraph and separating out concerns. The post modulation blocks from the original flowgraph were then transplanted and connected to the the new GFSK modem block. Testing confirmed a performant transmission without buffering issues. However environmental noise had a noticeably greater effect using the custom modem block than observed with the previous solution. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 186.67px;"><img alt="Screen Shot 2014-12-16 at 2.27.07 AM.png" src="images/image05.png" style="width: 624.00px; height: 186.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 5: the physical layer flow graph utilizing a custom GFSK modem block</span></p><p class="c7"><span>The finalized physical flowgraph was responsible for the modulation and frequency translation of the PDUs received from the networking/application layers. The discovery of the gr-mac project and the subsequent changes to block design allowed for better organization and alleviated issues with using the rudimentary packet blocks apart of GNURadio. After modifying the modem block to utilize a GFSK modulator and demodulator resilience to noise was increase, however never returned to the levels noticed with the original flowgraph design. The unified topblock model, with both Tx and Rx, was named Acoust. The focus at this point turned to the design of the protocol and finally its implementation.</span></p><p class="c1"><span></span></p><h1 class="c7 c14"><a name="h.2iibhb4drgaw"></a><span class="c4">CHAPTER 3: PROTOCOL</span></h1><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>Protocol design was researched and experimented with directly after the original creation and testing phase of AcoustIn and AcoustOut. Several ideas were entertained during this phase, inspired by protocols such I2C, ALOHANET, Google Protocol Buffers, and MAC. Our designs began with the packet and a set of classes to serialize and deserialize packets. These chosen language was Python due to its easy integration with GNURadio and its general programmer convenience. After creating a packet, several systems were proposed and tested to integrate the different layers. These systems were implemented in python and relied on file based IPC. The first system relied on nested classes that bound components together. While functional, problems on the physical layer led to this being considered. </span></p><p class="c2 c13"><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 42.67px;"><img alt="packet.png" src="images/image02.png" style="width: 624.00px; height: 42.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 6: packet design for a 32 byte packet and a max payload of 22 bytes</span></p><p class="c2 c13"><span class="c11"></span></p><p class="c7"><span>Although the initial step of constructing the packet might be perceived as premature, several modifications were made to the packet to adjust for changes in the overall protocol. One technical constraint observed early on was the need for a standardized packet length when passing to the data/physical layer (Figure 6). Because of this the packet was designed around 32 bytes, a compromise between speed and size of transmission. To support variable length payloads it was necessary to include a length field. This was sized appropriately based on the distribution of 32 bytes to the other fields. The destination and source constituted 2 bytes. The ID was given a large number of bytes to prevent transmission errors because of the birthday paradox. If the ID was not sufficiently sized it would inevitably result in a situation where in an allotted time a packet with an identical ID would be observed in the network. Duplicate packets within a time window destroy mechanisms that ensure packet delivery and can result in loss of data integrity. The ID was originally based on a MD5 hash of the concatenation of the source, destination, length, and payload cut down to 5 bytes. While this makes sense to identify a packet, it does not identify a packet anymore than the packet itself. Therefore a millisecond timestamp was included in the concatenation. Two transmissions of identical data from the same source to the same destination would have deferring IDs because of the variation of transmission time. Finally the last modification to the ID was the inclusion of counts in the first two bytes. The most significant byte was designated as the packet number and the next significant byte was designated as the total number of packets apart of the datagram. To test the packet serialization several packets were created and deserialized to confirm the predetermined</span><span>&nbsp;values.</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>Packets represent divided data, but what if an application decides to send a payload that is greater than 22 bytes? To support large datagrams an application-to-network wire format was implemented to deliver data to the network layer where it would be segmented into the aggregate packets. Rather than write numerous serialization and deserialization procedures in different languages, Google Protocol Buffers was used to describe the message format and then generate relevant classes for various languages (Figure 7). The message was given an address and data field. The address field was multipurpose, used for the destination address in the case of outgoing data and the source address for incoming data. The data field was variable and able to support arbitrarily large payloads. The completed datagram, named AcoustAppData, would be sent to the network layer where it would be partitioned into packets to be sent over the wire.</span></p><p class="c2 c12"><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 322.00px; height: 77.00px;"><img alt="Screen Shot 2014-12-16 at 7.05.42 PM.png" src="images/image03.png" style="width: 322.00px; height: 77.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp;</span></p><p class="c3"><span class="c11">Figure 7: AcoustAppData message definition</span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>After defining over the wire data formats, the next step involved designing the protocol logic. The network needed to support multiple nodes with no centralized master router. Nodes needed to route and forward data intelligently on their own. Initial considerations involved designs with arbitration periods. Technical restraints led to designs multiple channels and control channel mechanisms. Finally the design turned to assigning unique channels to each node within mutual range. The process also moved from standalone Python code operating independently from GnuRadio and interfacing via IPC to a system where a custom block interacted directly with the GnuRadio flowgraph. </span></p><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 173.00px;"><img alt="inrange.png" src="images/image04.png" style="width: 192.00px; height: 173.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 8: all nodes in audible range, the ideal situation for P1</span></p><p class="c1"><span class="c11"></span></p><p class="c7"><span>The first protocol (P1) design remained simple and relied on an echo confirmation of a nodes transmission. Transmissions from a node were verified via echo. If the echo verification failed it was assumed that the transition failed and the node would either restart transmission or remain silent for a random duration. If the node was in the midst of transmitting a datagram, that is it had already successfully transmitted some number of packets, the node would retry the failed packet transmission. If a node was just beginning transmission, it would stop trying to transmit and wait a random duration of time before attempting transmission again. This system ensured nodes that successfully began transmitting would be able to continue transmitting after interruption. Any node that needs to transmit attempts to, and if a node is already transmitting, it backs off and waits some interval of time. While the system works well in situations where the source and destination are in range (Figure 8) it is not sufficient for situations where there is some number of hops and multiple nodes clustered between (Figure 9). Why not simply check whether a node is speaking prior to transmitting? No atomic operation exists to check whether another node is transmitting and if not then start transmitting. Race conditions occur in the time between a node checking to see if a channel is clear and starting transmission. GNURadio does not support the access to hardware necessary to alleviate this problem. </span></p><p class="c2 c13"><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.00px; height: 177.00px;"><img alt="p1ideal.png" src="images/image01.png" style="width: 292.00px; height: 177.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 9: the complex mesh network, the worst case situation for P1</span></p><p class="c1"><span class="c11"></span></p><p class="c7"><span>To alleviate issues with arbitration in clustered hops several options were considered. In robust protocols best path routing occurs to preplan the path a stream of packets will travel and eliminate arbitration situations. Only certain nodes are responsible for forwarding packets. The forwarding events are orchestrated via separate control channels. These channels are also responsible for acknowledgments of successful transmissions and discovery when new nodes are introduced to the mesh. The additional complexity of multiple control channels was deemed out of scope, but the alleviation to traffic on the transmission channel by offloading to a single control channel appeared both achievable and would alleviate the problem with clustered arbitration. The control channel in our implementation operated on a separate configured frequency and played two roles: routing and acknowledgement of data. Prior to sending data a source confirms the presence of a destination in the mesh and after a packet successfully arrives an acknowledgement is sent to the source. The source uses a timeout mechanism based on the time elapsed time of the original acknowledgment to determine if a packet failed to receive. The packet is only retransmitted if it is confirmed that subsequent packets after the failed transmission were received. If transmission is not confirmed after a single failed packet the entire transmission is discarded and the host is considered unreachable. The application layer is not made aware of this event (a point of fault). This protocol, P2, was considered more robust than P1 but overall of excessive complexity. The wire transfer speeds were insufficient to support such a model. At this point it was apparent that a simplistic protocol that completely alleviated crosstalk was necessary for a satisfactory implementation. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span>The final considered protocol 3 (P3) was a different direction than P1 and P2. Rather than have public transmission channels, nodes would go through an initial discovery process. Nodes would identify channels, from a preconfigured list of channels, that were unoccupied. After a single node assumes control of a channel it constructs a list of the various in range nodes. All nodes construct a hashmap of nodes and channels. A node is then able to freely transmit on its own channel to all in range nodes. A source node would broadcast its packet directly to its destination node if said destination is in its local hashmap. If not the source node broadcasts the packet to all nodes within its range. These nodes do the same, forwarding a packet exactly once. The clustered hop problem is alleviated because each node speaks on a separate channel. The destination node might receive its packet from multiple sources. All duplicates are discarded and after the receipt of the packet an acknowledgement is returned to the originating host. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span>The three protocol considerations, P1, P2, and P3 were all weighed in there approach. In some cases a partial implementation of the protocol was completed (P1). In others the protocol was only conceptualized (P2). P3 was the perceived best option at the time, but quickly became clear to infeasible in the implementation stage. The final protocol implementation was a modified P1. Based on findings in the implementation and testing phase. The description of functionality follows:</span></p><p class="c2 c13"><span></span></p><ul class="c18 lst-kix_hxhbaganimh7-0 start"><li class="c7 c6 c8"><span>All nodes operate on the same channel</span></li><li class="c7 c6 c8"><span>Packets are unacknowledged</span></li><li class="c7 c6 c8"><span>A source and destination are presumed to be in range, different topography is not handled</span></li></ul><p class="c2 c13"><span></span></p><p class="c7"><span>This design dramatically simplifies the networking layer removing all robustness. This approach was taken after low transmission times and noise from many frequencies from a rudimentary P3 implementation made it clear that the protocol would not be able to operate with such extreme latencies. While disappointing, the nature of such networks doesn&rsquo;t call for reliability, but purely for data transmissions in extreme situations. In a covert setting, the receipt of data is not guaranteed by any means. The ideal situation would be a continual transmission, a beacon of sorts, of the data to be extracted. To extract data a node would be introduced with the sole purpose of picking up this data. With these concessions the implementation was both feasible and rudimentarily functional. </span></p><p class="c2 c13"><span></span></p><h1 class="c7 c14"><a name="h.wqa2prxdtwq9"></a><span class="c4">CHAPTER 4: IMPLEMENTATION</span></h1><p class="c2 c13"><span></span></p><p class="c7"><span>The final implementation saw a major shift in style inspired from the work of the gr-mac project. The protocol was implemented as a GNURadio block named AcoustProto apart of the flowgraph (Figure 10). AcoustProto was exposed to the application via a UDP server. Through this system an application would connect to the UDP server, send its AcoustAppData datagram and expect to receive responses as AcoustAppData datagrams. The protocol logic operates on sinks connected to the other blocks in the system. From input AcoustProto either forwards or consumes data. See </span><span>Appendix 6</span><span>&nbsp;for the AcoustProto source. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span class="c17">#picture of final flowgraph, Figure 10</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>The implemented reference application was a simple, uniquely identified chat room application that supported sending messages via broadcast to the mesh (Figure 11). This provided reference shows proper interaction via UDP server with the network layer. </span></p><p class="c2 c13"><span></span></p><p class="c7"><span class="c17">#picture of application Figure 11</span></p><h1 class="c7 c14"><a name="h.3l410328t25g"></a><span class="c4">CHAPTER 5: TESTING</span></h1><p class="c7"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c7"><span>Several types of tests were performed throughout different stages of development. As more tests were performed, more obstacles revealed themselves. Data integrity tests were most often performed in order to ensure that data transmission and receive were successful with minimal errors and packet loss. In order to test the integrity of data being received and sent, subgroupings of tests were made to test edge cases and race conditions of the platform. Testing transmission at different heights was performed to determine how well the hardware could reliably send and receive. Tests were also performed to see the range of the laptop speakers and microphones. Tests across different frequencies were performed in order to determine the most reliable frequency to transmit and receive over.</span></p><p class="c2 c13"><span></span></p><p class="c7"><span>It was quickly realized that transmissions between nodes were both slow and unreliable. The recorded transmission speed was approximately 10 B/s for a minimum three second transmission. The only configuration deemed reliable was the all in range (Figure 12).</span></p><p class="c2 c13"><span></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 192.00px; height: 173.00px;"><img alt="inrange.png" src="images/image04.png" style="width: 192.00px; height: 173.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c11">Figure 12: all nodes in audible range, the ideal situation for P1</span></p><p class="c2 c13"><span></span></p><h1 class="c7 c14"><a name="h.uvfjja8iim8t"></a><span class="c4">CHAPTER 6: CONCLUSION</span></h1><p class="c2"><span></span></p><p class="c9"><span>In conclusion the implementation of the acoustical mesh network using commodity laptop hardware &nbsp;did not meet the expectations originally set. Transmission was too unreliable and not fit for robust self checking network protocols. While this was disappointing it was reasoned that the applications operating on top of the network would be designed in a way that did not assume verified transmission. Further, these applications would not be run on commodity hardware, but instead specialized hardware devices. A number of suggestions in regard to future study have been collected:</span></p><p class="c2"><span></span></p><ul class="c18 lst-kix_a6o5ekz6umr6-0 start"><li class="c9 c6 c8"><span>Seek alternate ways of implementing physical layer, explore options such as minimodem and other software defined radio applications</span></li><li class="c9 c6 c8"><span>Use specialized acoustic hardware</span></li><li class="c9 c6 c8"><span>Implement a low level kernel device rather than a high level interface</span></li></ul><p class="c2 c13"><span></span></p><p class="c7"><span>Despite the overall disappointment, the</span><span>&nbsp;researchers&rsquo; greater understanding of signal processing, independent research, implementation, and software engineering. This experience was considered valuable and well worth the effort. </span></p><h1 class="c9 c14"><a name="h.bgdzhfs1pix3"></a><span class="c4">REFERENCES</span></h1><p class="c2"><span></span></p><p class="c9 c6"><span>[1] Michael Hanspach and Michael Goetz, &quot;On Covert Acoustical Mesh Networks in Air,&quot; Journal of Communications, vol. 8, no. 11, pp. 758-767, 2013. doi: 10.12720/jcm.8.11.758-767</span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[2] Goetz, M.; Nissen, I, &quot;GUWMANET &mdash; Multicast routing in Underwater Acoustic Networks,&quot; Communications and Information Systems Conference (MCC), 2012 Military , vol., no., pp.1,8, 8-9 Oct. 2012</span></p><p class="c2 c6"><span class="c5"></span></p><p class="c9 c6"><span class="c5">[3] </span><span class="c5">Malsbury, &#39;Modular, Open-Source Software Transceiver for PHY/MAC Research&#39;, in </span><span class="c5 c11">ACM SIGCOMM</span><span class="c5">, Hong Kong, 2013, pp. 1-6.</span></p><p class="c2"><span class="c5"></span></p><h1 class="c9 c14"><a name="h.cwz5lwc5jyqh"></a><span class="c4">APPENDIX</span></h1><p class="c2"><span></span></p><p class="c9 c6"><span>[1] Online website with video demonstration: </span></p><p class="c9 c6"><span class="c10"><a class="c15" href="http://www.google.com/url?q=http%3A%2F%2Fnpgm.github.io%2Facoustic&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNG5HpXob4DRK1wwTpWhavuqiAUwrg">http://npgm.github.io/acoustic</a></span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[2] gr-mac source code: </span></p><p class="c9 c6"><span class="c10"><a class="c15" href="https://www.google.com/url?q=https%3A%2F%2Fgithub.com%2Fjmalsbury%2Fgr-mac&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGVjDxvB_ojL1UGe3anBLFz9yX2xQ">https://github.com/jmalsbury/gr-mac</a></span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[3] Presentation at GRCON 2013 detailing the gr-mac and its uses:</span></p><p class="c9 c6"><span class="c10"><a class="c15" href="https://www.google.com/url?q=https%3A%2F%2Fgnuradio.squarespace.com%2Fstorage%2Fgrcon13_presentations%2Fgrcon13_malsbury_phy_mac_primer.pdf&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFKR0CUYBFZx31HCpyIg7lAvwUsSA">https://gnuradio.squarespace.com/storage/grcon13_presentations/grcon13_malsbury_phy_mac_primer.pdf</a></span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[4] Mailing list discussion about the future of gr-mac:</span></p><p class="c9 c6"><span class="c10"><a class="c15" href="https://www.google.com/url?q=https%3A%2F%2Flists.gnu.org%2Farchive%2Fhtml%2Fdiscuss-gnuradio%2F2014-10%2Fmsg00078.html&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHlVcbr2SaOpBF49ZHzcsV1gO5q6A">https://lists.gnu.org/archive/html/discuss-gnuradio/2014-10/msg00078.html</a></span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[5] Github source</span></p><p class="c9 c6"><span class="c10"><a class="c15" href="http://www.google.com/url?q=http%3A%2F%2Fgithub.com%2Fnpgm%2Facoust&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNHFSj9CHJpszWV3Dh07QfP0IYk2VQ">http://github.com/npgm/acoust</a></span></p><p class="c2 c6"><span></span></p><p class="c9 c6"><span>[6] AcoustProto included source</span></p><p class="c2"><span></span></p><p class="c2"><span></span></p><p class="c2"><span></span></p><div><p class="c2 c21"><span class="c0"></span></p></div></body></html>